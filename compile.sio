var TokenKind = Enum("TokenKind", "IF THEN ELSE IDENT INT OPERATOR PRINT STRING VAR ASSIGN UNKNOWN EOF ENDLN METHOD BLOCKEND EQ INPUT DIV MUL MINUS PLUS LPAREN RPAREN FUNC RUN COMMA NEQ GREAT LESS RETURN ALGEBRA ALC COMMENT RETURN_TYPE IN WHILE RET BREAK LAMBDA GE LE ASSERT OR AND NONE RAISE TRUE FALSE NONE");

func Token(row_, column_, kind, data) {
    func as_tuple() {
        return tuple(row_, column_, kind, data)
    }
};

func Lexer(src) {
    var src = array();
    var idx = 0;
    var row = 1;
    var column = 1;

    var kws = dd(TokenKind.IDENT);
    update(kws, "print", TokenKind.PRINT);
    update(kws, "var", TokenKind.VAR);
    update(kws, "if", TokenKind.IF);
    update(kws, "=", TokenKind.ASSIGN);
    update(kws, "{", TokenKind.THEN);
    update(kws, "else", TokenKind.ELSE);
    update(kws, "}", TokenKind.BLOCKEND);
    update(kws, "return", TokenKind.RETURN);
    update(kws, "(", TokenKind.LPAREN);
    update(kws, ")", TokenKind.RPAREN);
    update(kws, ";", TokenKind.ENDLN);
    update(kws, "is", TokenKind.EQ);
    update(kws, "not", TokenKind.NEQ);
    update(kws, "*", TokenKind.MUL);
    update(kws, "/", TokenKind.DIV);
    update(kws, "-", TokenKind.MINUS);
    update(kws, "+", TokenKind.PLUS);
    update(kws, ">", TokenKind.GREAT);
    update(kws, "<", TokenKind.LESS);
    update(kws, ",", TokenKind.COMMA);
    update(kws, "input", TokenKind.INPUT);
    update(kws, "import", TokenKind.RUN);
    update(kws, "sio", TokenKind.RUN);
    update(kws, " {", TokenKind.RETURN_TYPE);
    update(kws, "in", TokenKind.IN);
    update(kws, "while", TokenKind.WHILE);
    update(kws, "ret", TokenKind.RET);
    update(kws, "break", TokenKind.BREAK);
    update(kws, "print", TokenKind.PRINT);
    update(kws, "ge", TokenKind.GE);
    update(kws, "le", TokenKind.LE);
    update(kws, "or", TokenKind.OR);
    update(kws, "and", TokenKind.AND);
    update(kws, "None", TokenKind.NONE);
    update(kws, "raise", TokenKind.RAISE);

    func lex_num() {
        var match = "";
        while idx < len(src) {
            while isdigit(grab(src, idx)) {
                var match = match + grab(src, idx);
                eat()
            }
        };
        return Token(row, column, INT, int(match))
    };

    func current_char_is_valid_in_an_identifier() {
            var current = grab(src, idx);
            return is_ident(current) or current is "."
    };

    func lex_ident() {
        var match_ = "";
        while idx < len(src) {
            while current_char_is_valid_in_an_identifier() {
                var match_ = match_ + grab(src, idx);
                eat()
            }
        };

        var kind = grab(kws, match_);
        return Token(row, column, kind, match)
    };

    func consume_whitespace() {
        while idx < len(src) {
            while is_space(grab(src, idx)) {
                eat()
            }
        }
    };

    if idx ge len(src) {
        | TODO: IMPLEMENT StopIteration |;
        StopIteration
    };
    consume_whitespace();
    var ch = grab(src, idx);
    if is_alpha(ch) {
        return lex_ident()
    }
    else {
        if is_digit(ch) {
            return lex_num()
        }
        else {
            | Make it so that this accepts ' as a valid char |;
            if ch is "[" {
                return lex_string_literal()
            }
            else {
                if ch is "|" {
                    return lex_comment()
                }
                else {
                    eat();
                    if grab(kws, ch) is TokenKind.IDENT {
                        update(kws, ch, TokenKind.UNKNOWN)
                    };
                    var kind_ = grab(kws, ch);
                    return Token(row, column, kind_, ch)
                }
            }
        }
    };

    func lex_string_literal() {
        assert grab(src, idx) is "[";
        eat();

        var literal = "";
        while idx < len(src) {
            while grab(src, idx) not "[" {
                var literal = grab(src, idx);
                eat()
            }
        };

        if idx ge len(src) {
            print "Missing end of string delimiter!";
            return Token(row, column, TokenKind.UNKNOWN, literal)
        };

        assert grab(src, idx) is "[";
        eat();
        return Token(row, column, TokenKind.STRING, literal)
    };

    func lex_comment() {
        assert grab(src, idx) is "|";
        eat();

        var comment = "";
        while idx < len(src) {
            while grab(src, idx) not "|" {
                var comment = grab(src, idx);
                eat()
            }
        };

        if idx ge len(src) {
            print "Missing end of comment; |; or just | at end of file";
            return Token(row, column, TokenKind.UNKNOWN, comment)
        };

        assert grab(src, idx) is "|";
        eat();
        return Token(row, column, TokenKind.STRING, comment)
    };

    func eat() {
        if grab(src, idx) is "\n" {
            var row = row + 1;
            var column = 1
        }
        else {
            var column = column + 1
        };
        var idx = idx + 1
    }
};


func State(name, val) {
    var vals = dict();
    array(
        func bind() {
            update(vals, name, val)
        },
        func lookup() {
            try {
                return grab(vals, name)
            }
            except {
                return grab(name, 3)
            }
        },
        bind(),
        lookup()
    )
};

func PrintNode(value) {
    array(
        func compile() {
            return "print('"+grab(value, 2)+"')"
        },
        func eval() {
            print grab(value, 3)
        },
        compile(),
        eval()
    )
};

func NumExpr(value) {
    array(
        func compile() {
            return value
        },
        func eval() {
            return value
        },
        compile(),
        eval()
    )
}

func String(string) {
    array(
        func compile() {
            return "'"+string+"'"
        },
        func eval() {
            return string
        },
        compile(),
        eval()
    )
};

func Assign(variable, assignment) {
    array(
        func compile() {
            return variable+" = "+grab(assignment, 2)
        },
        func eval() {
            var state_bind = State(variable, grab(assignment, 3));
            grab(state_bind, 2)
        },
        compile(),
        eval()
    )
};

func EarlyReturn(value) {
    value;
    return None
};

func EarlyBreak(value) {
    value;
    return None
};

func BreakNode(value) {
    array(
        func compile {
            return "break "+grab(value, 2)
        },
        func eval {
            return EarlyBreak(grab(value, 3))
        },
        compile(),
        eval()
    )
};

func ReturnNode(value) {
    array(
        func compile {
            return "return "+grab(value, 2)
        },
        func eval {
            return EarlyReturn(grab(value, 3))
        },
        compile(),
        eval()
    )
};

func InputNode(value) {
    array(
        func compile {
            return "input("+grab(value, 2)+")"
        },
        func eval {
            return input(grab(value, 3))
        },
        compile(),
        eval()
    )
};

func VarExpr(value) {
    array(
        func compile {
            return "input("+grab(value, 2)+")"
        },
        func eval {
            var state_look = State(value, None);
            return grab(state_look, 3)
        },
        compile(),
        eval()
    )
};

func RaiseNode(value) {
    array(
        func compile {
            return "raise "+grab(value, 2)
        },
        func eval {
            raise grab(value, 3))
        },
        compile(),
        eval()
    )
};

func IfExpr(cond, left, right) {
    array(
        func compile {
            if right not None {
                return "if "+grab(cond, 2)+": "+grab(left, 2)+" else: "+grab(right, 2)
            }
            else {
                return "if "+grab(cond, 2)+": "+grab(left, 2)
            }
        },
        func eval {
            if grab(cond, 3) {
                return grab(left, 3)
            }
            else {
                if right not None {
                    return grab(right, 3)
                }
            }
        },
        compile(),
        eval()
    )
};

func AssertNode(value) {
    array(
        func compile {
            return "assert "+grab(value, 2)
        },
        func eval {
            assert grab(value, 3)
        },
        compile(),
        eval()
    )
};

func TryExceptNode(left, right) {
    array(
        func compile {
            return "try: "+grab(left, 2)+" except: "+grab(right, 2)
        },
        func eval {
            try grab(cond, 3) {
                return grab(left, 3)
            }
            except {
                return grab(right, 3)
            }
        },
        compile(),
        eval()
    )
};

func TrueNode() {
    array(
        func compile {
            return "True"
        },
        func eval {
            return True
        },
        compile(),
        eval()
    )
};

func FalseNode() {
    array(
        func compile {
            return "False"
        },
        func eval {
            return False
        },
        compile(),
        eval()
    )
};

func NoneNode() {
    array(
        func compile {
            return "None"
        },
        func eval {
            return False
        },
        compile(),
        eval()
    )
};


class Parser(lexer) {
    var token = Token(1, 1, TokenKind.UNKNOWN, "dummy");
    var operators = array(TokenKind.PLUS, TokenKind.MINUS, TokenKind.MUL, TokenKind.DIV, TokenKind.EQ, TokenKind.NEQ, TokenKind.LESS, TokenKind.GREAT, TokenKind.IN, TokenKind.LE, TokenKind.GE, TokenKind.AND, TokenKind.OR);

    var token = next(lexer);
    
    func consume() {
        try {
            var next_token = next(lexer)
        }
        except {
            var next_token = None
        };
        
        if token {
            var rtt = token;
            var token = next_token;
            return rtt
        };
        return None
    };

    func expect(kind) {
        if token.kind is kind {
            return consume()
        };
        raise SyntaxError("Expected token kind"+kind+", found: "+token.kind+". Row: "+lexer.row+", Column: "+lexer.column)
    };

    func accept(kind) {
        if token is not None and  token.kind is kind {
            consume();
            return True
        }
        else {
            return False
        }
    };

    func parse_while() {
        var rtt = None;
        expect(TokenKind.WHILE);
        if accept(TokenKind.RET) {
            var rtt = ""
        };
        var cond = parse_statements();
        var then = parse_block();
        return WhileExpr(cond, rtt, then)
    };

    func parse_if() {
        expect(TokenKind.IF);
        var cond = parse_statements();
        var then = parse_block();
        var els = None;
        if accept(TokenKind.ELSE) {
            var els = parse_block()
        };
        return IfExpr(cond, then, els)
    };

    func prece(op) {
        if op is TokenKind.PLUS {
            return 1
        };
        if op is TokenKind.MUL {
            return 2
        };
        if op is TokenKind.DIV {
            return 2
        };
        if op is TokenKind.MINUS {
            return 1
        };
        if op is TokenKind.EQ or TokenKind.NEQ or TokenKind.IN or TokenKind.LE or TokenKind.GE or TokenKind.AND or TokenKind.OR {
            return 3
        }
    };

    func next_is_operator() {
        return token not None and token.kind in operators
    };

    func parse_operator_expr() {
        var first = parse_term();
        if next_is_operator() {
            var op = parse_operator();
            return parse_binop(first, op)
        }
        else {
            return first
        }
    };

    func expect_any(kinds) {
        if token.kind in kinds {
            return consume()
        }
    };

    func parse_operator() {
        return expect_any(operators).kind
    };

    func parse_binop(first, op) {
        var second = parse_term();
        if next_is_operator() {
            var next_ = parse_operator();
            if prece(op) ge prece(next_) {
                return parse_binop(BinOp(first, op, second), next_)
            }
            else {
                return BinOp(first, op,  parse_binop(second, next_))
            }
        }
        else {
            return BinOp(first, op, second)
        }
    };

    func parse_num() {
        var data = expect(TokenKind.INT).data;
        return NumExpr(data)
    };

    func parse_input() {
        expect(TokenKind.INPUT);
        var prompt = parse_expr();
        return InputNode(prompt)
    };

    func parse_var() {
        var data = expect(TokenKind.IDENT).data;
        return VarExpr(data)
    };
    
    func parse_alcall() {
        expect(TokenKind.ALC);
        var ident = expect(TokenKind.IDENT).data;
        return AlgebraicCalling(ident)
    };
    
    func parse_assign() {
        expect(TokenKind.VAR);
        var ident = expect(TokenKind.IDENT).data;
        expect(TokenKind.ASSIGN);
        var value = parse_expr();
        return Assign(ident, value)
    };
    
    func parse_alg() {
        expect(TokenKind.ALGEBRA);
        var ident = expect(TokenKind.IDENT).data;
        return AlgerbraicVariable(ident)
    };

    func parse_statements() {
        var left = parse_expr();
        while accept(TokenKind.ENDLN) {
            var right = parse_expr();
            var left = SequenceNode(left, right)
        };
        return left
    }

    func parse_block() {
        expect(TokenKind.THEN).data;
        var a = parse_statements();
        expect(TokenKind.BLOCKEND).data;
        return a
    };

    func parse_parenthesized_expr() {
        expect(TokenKind.LPAREN);
        var data = parse_operator_expr();
        expect(TokenKind.RPAREN);
        return data
    };

    func parse_print() {
        expect(TokenKind.PRINT);
        var d = parse_expr();
        return Print(d)
    };

    func parse_function() {
        expect(TokenKind.FUNC);
        var name = expect(TokenKind.IDENT).data;
        expect(TokenKind.LPAREN);
        var params = array();
        var rt = None;
        while token.kind is TokenKind.IDENT {
            append(params, expect(TokenKind.IDENT).data);
            accept(TokenKind.COMMA);
            expect(TokenKind.RPAREN)
        };
        if accept(TokenKind.RETURN_TYPE) {
            var rt = parse_term()
        };
        var code = parse_block();
        return FunctionNode(name, params, rt, code)
    };

    func parse_return() {
        expect(TokenKind.RETURN);
        var value = parse_operator_expr();
        return rtturnNode(value)
    };

    func parse_raise() {
        expect(TokenKind.RAISE);
        var value = self.parse_expr();
        return RaiseNode(value)
    };

    func parse_break() {
        expect(TokenKind.BREAK);
        var value = parse_operator_expr();
        return BreakNode(value)
    };

    func parse_call(name) {
        var args = array();
        while token.kind not TokenKind.RPAREN {
            append(args, parse_expr());
            accept(TokenKind.COMMA);
            expect(TokenKind.RPAREN)
        };
        return Call(name, args)
    };
 
    func parse_run() {
        expect(TokenKind.RUN);
        var file = expect(TokenKind.STRING).data;
        return Run(file)
    };

    func parse_string() {
        var data = expect(TokenKind.STRING).data;
        return String(data)
    };

    func parse_comment() {
        var data = expect(TokenKind.COMMENT).data;
        return Comment(data)
    };

    func parse_true() {
        expect(TokenKind.TRUE);
        return TrueNode()
    };
    
    func parse_false() {
        expect(TokenKind.FALSE);
        return FalseNode()
    };
    
    func parse_none() {
        expect(TokenKind.NONE);
        return NoneNode()
    };

    func parse_assert() {
        expect(TokenKind.ASSERT);
        var value = parse_operator_expr();
        return AssertNode(value)
    };

    func parse_try_except() {
        expect(TokenKind.TRY);
        var left = parse_block();
        expect(TokenKind.EXCEPT);
        var right = parse_block();
        return TryExceptNode(left, right)
    };

    func parse_term() {
        var t = token.kind;
        if t is TokenKind.IDENT {
            var name = expect(TokenKind.IDENT).data;
            if accept(TokenKind.LPAREN) {
                return parse_call(name)
            }
            else {
                return VarExpr(name)
            }
        };
        if t is TokenKind.INT {
            return parse_num()
        };
        if t is TokenKind.STRING {
            return parse_string()
        };
        if t is TokenKind.COMMENT {
            return parse_comment()
        };
        if t is TokenKind.TRUE {
            return parse_true()
        };
        if t is TokenKind.FALSE {
            return parse_false()
        };
        if t is TokenKind.NONE {
            return parse_none()
        };
        if t is TokenKind.LPAREN {
            return parse_parenthesized_expr()
        }
        else {
            raise SyntaxError(f"Unexpected token"+t+". Row: "+lexer.row+", Column: "+lexer.column)
        }
    };
 
    func parse_expr() {
        if token is None {
            raise SyntaxError(f"Unexpected EOF. Row { { lexer.row}, Column { { lexer.column}")
        };
        var t = token.kind;
        if t is TokenKind.IF {
            return parse_if()
        };
        if t is TokenKind.WHILE {
            return parse_while()
        };
        if t is TokenKind.PRINT {
            return parse_print()
        };
        if t is TokenKind.VAR {
            return parse_assign()
        };
        if t is TokenKind.ALGEBRA {
            return parse_alg()
        };
        if t is TokenKind.INPUT {
            return parse_input()
        };
        if t is TokenKind.FUNC {
            return parse_function()
        };
        if t is TokenKind.RUN {
            return parse_run()
        };
        if t is TokenKind.RETURN {
            return parse_return()
        };
        if t is TokenKind.BREAK {
            return parse_break()
        };
        if t is TokenKind.TRY {
            return parse_try_except()
        };
        if t is TokenKind.RAISE:
            return self.parse_raise()
        if t is TokenKind.ASSERT {
            return parse_assert()
        };
        if t is TokenKind.ALC {
            return parse_alcall()
        else {
            return parse_operator_expr()
        }
    }
};

var inpt = input "COMPILER >>> ";

print Lexer(inpt)
